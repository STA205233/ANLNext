ANL Next
========================================

- Version: 1.4.2
- Author: Hirokazu Odaka


Introduction
----------------------------------------

ANL Next is a framework to generate software which performs event-by-event
analysis. The event-by-event analysis is defined as data analysis which treats
a list of event entries as input and applies some processes to each event
entry. Since algorithm for each entry must be identical for all events, the
entire program consists of a loop of a procedure that realizes the algorithm
for all the entires. We usually need such a data processing for experimental
data obtained with radiation detectors including X-ray and gamma-ray telescopes
for high-energy astrophysics.

ANL Next provides us with easy ways to develop and run a software application
of event-by-event analysis. In this framework, an analysis loop is treated as
an "analysis chain", which is a list of "ANL modules". Each ANL module is
responsible for one single task, or relatively simple process. In a single
loop, the manager process sequentially calls ANL modules in the analysis chain.
In this scheme, Users can concentrate on the simple task applied to one event
entry. Once modules are prepared, the users can run applications with various
configurations of the analysis chain, without additional development.

While ANL Next adopts the conventional ANL concept about the event-by-event
loop, we have written the code completely from scratch. This framework is
written in C++, and provides Ruby binding (extention library) for dynamical and
flexible use of analysis applications. To operate an analysis applications,
what you need to do is only writing a simple Ruby script, in which you define
an analysis chain and set parameters to the ANL modules. The application build
by ANL Next are as fast as C++ code, and as flexible as Ruby code.

This framework is originated from the ANL++ framework (by Shin Watanabe), which
is C++ implementation of ANL. The original ANL was a data analysis framework
developed by the PEP-4 TPC collaboration at the Lawrence Berkeley Laboratory
in 1980s. It has been improved on data sharing methods between ANL modules in
1990s by T. Takahashi, H. Kubo, Y. Ishisaki, et al., and maintenaced for data
processing of X-ray detectors onboard the ASCA and Suzaku X-ray observatories.

### Contact

- Hirokazu Odaka 
- ISAS/JAXA
- odaka(AT)astro.isas.jaxa.jp

### GitHub

https://github.com/odakahirokazu/ANLNext/

### Supported Platform

- Mac OS X
- Linux (not frequently tested)

#### Test environmemt

- Mac OS X 10.9.2
- Apple LLVM version 5.0 (clang-500.2.79) (based on LLVM 3.3svn)
- Ruby 2.0.0-p353
- Boost 1.55.0

### API Reference

http://www.astro.isas.jaxa.jp/~odaka/anlnext/doxygen/


ANL model
----------------------------------------

(now writing...)


Installation
----------------------------------------

### Required Software

#### (1) C++ compliler

#### (2) [Boost C++ library](http://www.boost.org/)
*version 1.53.0 or later*

#### (3) [CMake](http://www.cmake.org/)
*version 2.8.11 or later*

This package uses CMake (Cross platform make) for easy installation.

#### (4) [Ruby](http://www.ruby-lang.org/en/)
*Ruby 2.0 is recommended.*

ANL Next provides a Ruby extended library, which is generated by SWIG, as
interface to operate an analysis software generated by this framework. Ruby is
a scriptable, dynamic, object-orriented programming language, and offers
powerful and flexible interface to control the user program. Ruby is widely
used in the world, and is easy to learn like Python. This is optional but very
useful for productive data analysis.

#### (5) [SWIG](http://www.swig.org/)
*version 2.0.9 or later*

As SWIG (Simplified Wrapper and Interface Generator) provides an easy way to
generate extended libraries of various scripting languages, ANL Next uses SWIG
for making Ruby binding of itself.


### Installation Guide

#### (1) Obtain ANL Next

    $ git clone git://github.com/odakahirokazu/ANLNext.git

#### (2) Perform CMake

Make a directory for building the software, and then move to the directory.

    $ cd ANLNext
    $ mkdir build
    $ cd build

Perform cmake to generate Makefiles. Give the directory of the source tree to
`cmake` command.

    $ cmake .. [options] -DCMAKE_INSTALL_PREFIX=/path/to/install

There are several options:

- `ANL_USE_RUBY` (Default=ON): enable Ruby binding.
- `ANL_USE_EXE` (Default=OFF): enable standalone executables.
- `ANL_USE_TVECTOR` (Default=OFF): enable ROOT vector.
- `ANL_USE_HEPVECTOR` (Default=OFF): enable CLHEP vector.
- `ANL_USE_G4VECTOR` (Default=OFF): enable Geant4-CLHEP vector.
- `ANL_INSTALL_HEADERS` (Default=ON): install all header files.
- `ANL_INSTALL_CMAKE_FILES` (Default=ON): install all cmake files.

By default, the install destination is set to `${HOME}`. So `make install` will
install headers and libraries into the user's home directory, such as
`${HOME}/include` or `${HOME}/lib`. You can change it by setting
`CMAKE_INSTALL_PREFIX`.

#### (3) Make and install

    $ make -jN (N: number of parallel complilation processes)
    $ make install

#### (4) Set environment variables

If you installed ANL Next into the $HOME directory (default destination), you
need to set the following environment variables:  
(example for bash/zsh)

    export DYLD_LIBRARY_PATH=${HOME}/lib:${DYLD_LIBRARY_PATH}
    export RUBYLIB=${HOME}/lib/ruby:${RUBYLIB}

Or, you may need to set the following envrionment variables:

    export ANLNEXT_INSTALL=/path/to/install
    export DYLD_LIBRARY_PATH=${ANLNEXT_INSTALL}/lib:${DYLD_LIBRARY_PATH}
    export RUBYLIB=${ANLNEXT_INSTALL}/lib/ruby:${RUBYLIB}


Getting Started
----------------------------------------

By using this framework, you can easily construct your own applications. If
you want a new application containing only existing modules, you can quickly
start with writing a Ruby script that defines an **analysis chain** descibing
an order of the ANL modules and sets parameters passed to the modules. This
enviroment provides you with powerful and flexible scripting framework.

### How to write a Ruby script operating an ANL application

The ANL Next framework provides Ruby binding. This feature makes the framework
flexible and powerful. To use the extension libarary, it is necessary to
*require* ANL libraries.

```ruby
require 'ANLLib' # ANL Next library
require 'comptonSoft' # One of Ruby extension libararies using ANL Next

include ComptonSoft # need to include the module
```

At the begenning, we need to define an analysis chain, which specifies the
order of ANL modules.

```ruby
# create an ANL application.
anl = ANLApp.new

# define an analysis chain.
anl.chain :SaveData
anl.chain :CSHitCollection
anl.chain :ConstructDetector
anl.chain :ConstructChannelTable
anl.chain :ReadDetectorHitTree
anl.chain :AnalyzeHit
anl.chain :EventSelection
anl.chain :HitTree_Sim
```

Then, we set parameters of the modules. If you do not set parameters here,
default values will be assigned.
```ruby
anl.set_parameters :SaveData, {
  "Output file" => "output.root",
}

anl.set_parameters :ConstructDetector, {
  "Detector configuration file" => "database/detector_configuration_HXI.xml",
}

anl.set_parameters :EventSelection, {
  "Detector group file" => "database/detector_group_HXI.txt",
  "Remove veto events?" => true,
  "Range of fluorescence lines" => 1.0,
}
```

If an ANL module has a map parameter, you can insert a new map element in
this way:

```ruby
anl.set_parameters :AnalyzeHit
anl.insert_map "Analysis map", "CdTe", {
  "Detector type" => 2,
  "Analysis mode" => 4,
  "Threshold (cathode)" => 5.0,
  "Threshold (anode)" => 5.0,
}
anl.insert_map "Analysis map", "Si", {
  "Detector type" => 2,
  "Analysis mode" => 4,
  "Threshold (cathode)" => 3.0,
  "Threshold (anode)" => 5.0,
}
anl.insert_map "Analysis map", "BGOTop", {
  "Detector type" => 3,
  "Analysis mode" => 0,
  "Threshold" => 100.0,
}
```
    
After setting the parameter, just run the ANL. The number of the analysis loop
can be passed through the first argument. The second argument is optional for
setting the display frequency.

```ruby
anl.run(100000)
```

If you need to set infinite loop, set -1 as the loop number. The second
argument is the display frequency (optional).

```ruby
anl.run(-1, 100000)
```


Development of Your Applications
----------------------------------------

If you want to develop analysis software which applies your original algorithm,
you need to develop a new ANL module. You can find a simple example of your own
ANL application in *examples* directory.

### Design

### ANL Module

#### Structure of ANL module

#### Methods defined in an ANL module

#### Registering parameters

### Data Sharing between ANL Modules
    
#### Event selection flag (EVS)

#### Accessing information in other modules

You can access other modules via GetANLModule() method.

```c++
// Declaration of a const pointer to a module you want to access.
const YourModule* module;

// Get a pointer to the module.
GetANLModule("YourModule", module);

// Get some parameter via a member method of the module.
// The member method must be declared as const.</span>
int yourParam = module->getYourParam();
```

#### Action to other modules without "const"

GetANLModuleNC() gives non-const pointer of a module. NC stands for non-const.

```c++
// Declaration of a pointer to a module you want to access.
YourModule* ym;

// Get a pointer to the module.
GetANLModuleNC("YourModule", ym);

// Call methods of the module.
ym->setMode(mode);
ym->doSomething();
```
    
#### Ruby binding

#### Build settting

#### Run

****************************************
