<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  
  <head>
    <meta name="author" content="ODAKA Hirokazu" />
    <meta name="copyright" content="Copyright (c) 2008 Hirokazu Odaka and Compton Team" />
    <link rel="stylesheet" href="design_top.css" type="text/css" />
    <title>ANL Next Framework</title>
  </head>

  <body>
    <!--div><a href="index.html">Home</a></div-->
    
    <h1>ANL Next Framework</h1>
    
    <h2>1. Introduction</h2>
    
    <p>ANL Next is a framework to generate software which performs event-by-event analysis. The event-by-event analysis is defined as data analysis which treats a list of event entries as input and applies some processes to each event entry. Since algorithm for each entry must be identical for all events, the entire program consists of a loop of a procedure that realizes the algorithm for all the entires. We usually need such a data processing for experimental data obtained with radiation detectors including X-ray and gamma-ray telescopes for high-energy astrophysics.</p>

    <p>ANL Next provides us with easy ways to develop and run a software application of event-by-event analysis. In this framework, an analysis loop is treated as an "analysis chain", which is a list of "ANL modules". Each ANL module is responsible for one single task, or relatively simple process. In a single loop, the manager process sequentially calls ANL modules in the analysis chain. In this scheme, Users can concentrate on the simple task applied to one event entry. Once modules are prepared, the users can run applications with various configurations of the analysis chain, without additional development.</p>

    <p>While ANL Next adopts the conventional ANL concept about the event-by-event loop, we have written the code completely from scratch. This framework is written in C++, and provides Ruby binding (extention library) for dynamical and flexible use of analysis applications. To operate an analysis applications, what you need to do is only writing a simple Ruby script, in which you define an analysis chain and set parameters to the ANL modules. The application build by ANL Next are as fast as C++ code, and as flexible as Ruby code.</p>

    <p>This framework is originated from the ANL++ framework (by Shin Watanabe), which is C++ implementation of ANL. ANL is a fundamental framework of event-by-event analysis, which has been used for data processing of X-ray detectors on board ASCA and Suzaku X-ray observatories.</p>
    
    <h3>github</h3>
    <p><a href="https://github.com/odakahirokazu/ANLNext/">https://github.com/odakahirokazu/ANLNext</a></p>

    <h3>Contact</h3>
    <p>Hirokazu Odaka<br />ISAS/JAXA<br />odaka(AT)astro.isas.jaxa.jp</p>

    <h2>2. Installation</h2>
    <p>See <a href="https://github.com/odakahirokazu/ANLNext#readme">README</a> on the github repository.</p>
    
    <h2>3. Getting Started</h2>
    <h3>3.1 For Application Users</h3>
    <h3>3.2 Structure of an ANL Module</h3>
    
    <h2>4. How to Make Your Own Applications</h2>
    <p>By using this framework, you can easily construct your own applications. If you want a new application containing only existing modules, you can quickly start with writing a Ruby script that defines an "analysis chain" descibing an order of the ANL modules and sets parameters passed to the modules (4.1). This enviroment provides you with powerful and flexible scripting framework. If you want to develop analysis software which applies your original algorithm, you need to develop a new ANL module (4.2).</p>

    <h3>4.3 Use of Ruby Interface</h3>
    <p>The ANL Next framework provides Ruby binding. This feature makes the framework flexible and powerful.</p>
    <p>To use the extension libarary, it is necessary to "require" ANL libraries.</p>
    <pre class="example">
require 'comptonSoft' # One of Ruby extension libararies.
require 'ANLLib' # Utility library for the ANL-Ruby binding
    </pre>
    <p>At the begenning, we define an analysis chain composed of ANL modules.</p>
    <pre class="example">
anl = ANLApp.new
anl.chain :SaveData
anl.chain :CSHitCollection
anl.chain :ConstructDetector_Sim
anl.chain :SetNoiseLevel
anl.chain :ReadGDML
anl.chain :AHStdPhysicsList_ANL
anl.chain :PlaneWaveRectanglePrimaryGen
anl.chain :Geant4Body
anl.chain :NextPickUpData
anl.chain :MakeDetectorHit
anl.chain :EventSelection
anl.chain :HitTree_Sim
    </pre>

    <p>Then, we set parameters of the modules. If you do not set parameters here, default values will be assigned.</p>
    <pre class="example">
dbDir = "../database/"
anl.set_parameters :SaveData, {
  'Output file' => "sim_compton_camera.root"
}

anl.set_parameters :ConstructDetector_Sim, {
  'Detector configuration file' => dbDir+'detector_config_sgd.xml',
  'Simulation parameter file' => dbDir+'sdlist_sgd.xml',
}
    </pre>
    <p>If an ANL module has a map parameter, you can insert a new map element in this way:</p>
    <pre class="example">
anl.set_parameters :SetNoiseLevel
anl.insert_map 'Noise level map', 'Si', {
  'Detector type' => 1,
  'Noise parameter 00' => 1.5,
  'Noise parameter 01' => 0.0,
  'Noise parameter 02' => 0.003,
}
anl.insert_map 'Noise level map', 'CdTe', {
  'Detector type' => 1,
  'Noise parameter 00' => 1.6,
  'Noise parameter 01' => 0.0,
  'Noise parameter 02' => 0.01,
}
    </pre>

    <p>After setting the parameter, just run the ANL. The number of the analysis loop can be passed through the first argument. The second argument is optional for setting the display frequency.</p>
    <pre class="example">
anl.run(10000)
    </pre>

    
    <h3>4.2 Development of an ANL Module</h3>
    <p>TBD</p>
    <h4>Accessing information in other modules</h4>
    <p>You can access other modules via GetANLModule() method.</p>
    <pre class="example"><span class="code_comment">// Declaration of a const pointer to a module you want to access.</span>
const YourModule* ym;

<span class="code_comment">// Get a pointer to the module.</span>
GetANLModule("YourModule", ym);

<span class="code_comment">// Get some parameter via a member method of the module.</span>
<span class="code_comment">// The member method must be declared as const.</span>
int yourParam = ym->getYourParam();
</pre>

    <h4>Accessing information in other modules</h4>
    <p>GetANLModuleNC() gives non-const pointer of a module. NC stands for non-const.</p>
    <pre class="example"><span class="code_comment">// Declaration of a pointer to a module you want to access.</span>
YourModule* ym;

<span class="code_comment">// Get a pointer to the module.</span>
GetANLModuleNC("YourModule", ym);

<span class="code_comment">// Call methods of the module.</span>
ym->setMode(mode);
ym->doSomething();
</pre>
    

    <h2>Class Library Reference</h2>
    
    <div>
      <hr />
      <address>e-mail: odaka(AT)astro.isas.jaxa.jp</address>
    </div>
    
  </body>
</html>
