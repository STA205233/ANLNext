<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  
  <head>
    <meta name="author" content="ODAKA Hirokazu" />
    <meta name="copyright" content="Copyright (c) 2008-2011 Hirokazu Odaka and Compton Team" />
    <link rel="stylesheet" href="design_top.css" type="text/css" />
    <title>ANL Next Framework</title>
  </head>

  <body>
    <!--div><a href="index.html">Home</a></div-->
    
    <h1>ANL Next Framework</h1>
    
    <h2>1. Introduction</h2>
    
    <p>ANL Next is a framework to generate software which performs event-by-event analysis. The event-by-event analysis is defined as data analysis which treats a list of event entries as input and performs something interesting for each event entry. Since algorithm for each entry must be identical for each event, the entire program consists of a loop of a procedure which realize the algorithm for all the entires. We usually need such a data processing for experimental data obtained with radiation detectors.</p>
    <p>This framework is originated by the ANL++ framework (by Shin Watanabe), which is C++ implementation of ANL. ANL is a fundamental framework of event-by-event analysis, which has been used for data processing of X-ray detectors on board ASCA and Suzaku X-ray observatories.</p>
    <p>As ANL Next adopts the ANL concept, we have written the code completely from scratch. This framework is written in C++, and provides Ruby binding for dynamical and flexible use of analysis software.</p>

    <h3>github</h3>
    <p><a href="https://github.com/odakahirokazu/ANLNext">https://github.com/odakahirokazu/ANLNext</a></p>

    <h3>Contact</h3>
    <p>Hirokazu Odaka<br />ISAS/JAXA<br />odaka(AT)astro.isas.jaxa.jp</p>

    <h2>2. Installation</h2>
    <h3>2.1 Supported system</h3>
    <ul>
      <li>Mac OS X (standard environment of the authors)</li>
      <li>Linux (will be supported)</li>
    </ul>

    <h3>2.2 Required software</h3>
    <h4>a) C++ compliler</h4>
    
    <h4>b) <a href="http://www.cmake.org/">CMake</a> (Cross platform make)</h4>
    <p>[version 2.8 or later]</p>
    <p>For easy installation, this package uses CMake to generate building tools such as Makefile.</p>

    <h4>c) <a href="http://www.boost.org/">Boost C++ library</a></h4>
    <p>[version 1.47.0 or later]</p>
    <p>Because ANL Next uses "header-only" libraries of Boost, you do not need to build the library. Just uncompress the Boost package and place it to location you want to install. Then, register its location to header including path of C++ compiler. For example, add to .bashrc the line below:</p>
    <pre class="example">% export CPLUS_INCLUDE_PATH=${CPLUS_INCLUDE_PATH}:pass/to/boost</pre>

    <h4>d) <a href="http://www.ruby-lang.org/">Ruby</a> (option)</h4>
    <p>[version 1.8.6 or later]</p>
    <p>ANL Next provides a Ruby extended library, which is generated by SWIG, as interface to operate an analysis software generated by this framework. Ruby is a scriptable, dynamic, object-orriented programming language, and offers powerful and flexible interface to control the user program. Ruby is widely used in the world, and is easy to learn like Python. This is optional but very useful for productive data analysis.</p>

    <h4>e) <a href="http://www.swig.org/">SWIG</a> (Simplified Wrapper and Interface Generator) (option)</h4>
    <p>[version 2.0 or later]</p>
    <p>As SWIG provides an easy way to generate extended libraries of various scripting languages, ANL Next uses SWIG for making Ruby binding of itself.</p>
    
    <h4>f) <a href="http://proj-clhep.web.cern.ch/proj-clhep/">CLHEP</a> (option)</h4>
    <p>[version 2.1 or later]</p>
    <p>A class library for high energy physics. This is required by <a href="http://geant4.cern.ch/">Geant4</a> simulations. After Geant4 version 9.5, the Geatn4 package includes CLHEP.</p>

    <h4>g) <a href="http://root.cern.ch/drupal/">ROOT</a> (option)</h4>
    <p>[version 5.28 or later]</p>
    <p>A data analysis framework.</p>

    <h3>2.3 Installation</h3>
    <p>1) Obtain ANL Next</p>
    <pre class="example">% git clone git://github.com/odakahirokazu/ANLNext.git</pre>
    <p>2) We strongly recomend out-of-source building, in which building does not affect the source directory. Create a directory for building outside the source directory.</p>
    <pre class="example">% mkdir build_ANLNext
% cd build_ANLNext</pre>
    <p>3) Perform cmake to generate Makefiles. There are several options.</p>
    <ul>
      <li>USE_TVector [Default=OFF]: enable ROOT vector.</li>
      <li>USE_HepVector [Default=OFF]: enable CLHEP vector.</li>
      <li>USE_G4Vector [Default=OFF]: enable Geant4-CLHEP vector. Use this option for Geant4 version 9.5 or later.</li>
      <li>USE_Ruby [Default=ON]: enable Ruby binding.</li>
    </ul>
    <pre class="example">% cmake ../ANLNext [options]</pre>
    <p>If you want to use vector libraries of ROOT and CLHEP (Geant4 included), perform below:</p>
    <pre class="example">% cmake ../ANLNext -DUSE_TVector=ON -DUSE_G4Vector=ON</pre>
    <p>4) Make</p>
    <pre class="example">% make</pre>
    <p>5) Install. By default, "make install" will install binaries and libraries into the user's home directory, such as ${HOME}/bin or ${HOME}/lib.</p>
    <pre class="example">% make install</pre>
    <p>6) Set environment variable ANLNEXT_TOP as a path to the source tree. For example, add to .bashrc the line below:</p>
    <pre class="example">% export ANLNEXT_TOP=/path/to/ANLNEXT</pre>

    <h2>3. Getting Started</h2>
    <h3>3.1 For Application Users</h3>
    <h3>3.2 Structure of an ANL Module</h3>
    <h4>3.2.1 Abstract structure</h4>
    <h3>3.3 Ruby Binding</h3>
    
    <h2>4. How to Make Your Own Applications</h2>
    <p>By using this framework, you can easily construct your own applications. If you want a new application containing only existing modules, what you have to do is only writing an ANL definition file which describe an order of the modules (4.1). If you want to develop analysis software which applies your original algorithm, you have to develop a new ANL module (4.2). Section 4.3 describes use of Ruby binding, which is powerful and flexible scripting framework.</p>
    <h3>4.1 Build a standalone ANL Application</h3>
    <p>1) Write an ANL definition file of your application. The definition file is just an enumeration of ANL modules which compose the application. A line starting with # is regarded as a comment. Its file name have to be {application name}.def.</p>
    <p>Example of ANL definition file.</p>
    <pre class="example"># ANL application example: event_analysis.def
# This program analyzes an event data to output some hi
ReadRawData
EventCollection
GainCorrection
EventReconstruction
MakeSpectrum
MakeLightCurve
Make2DCorrelation
FormatReconstructedEvent
SaveDataToFile</pre>
    <p>2) Prepare CMakeLists.txt for cmake. After copying a template CMakeLists.txt, edit the file by adding required include directories and libraries.</p>
    <p>3) Make a Makefile by using cmake with the CMakeLists.txt.</p>
    <pre class="example">$ mkdir build_my_application
$ cd build_my_application
$ cmake ../my_application</pre>
    <p>4) Build and install.</p>
    <pre class="example">$ make
$ make install</pre>

    <h3>4.2 Development of an ANL Module</h3>
    <p>TBD</p>
    <h4>Accessing information in other modules</h4>
    <p>You can access other modules via GetANLModule() method.</p>
    <pre class="example"><span class="code_comment">// Declaration of a const pointer to a module you want to access.</span>
const YourModule* ym;

<span class="code_comment">// Get a pointer to the module.</span>
GetANLModule("YourModule", ym);

<span class="code_comment">// Get some parameter via a member method of the module.</span>
<span class="code_comment">// The member method must be declared as const.</span>
int yourParam = ym->getYourParam();
</pre>

    <h4>Accessing information in other modules</h4>
    <p>GetANLModuleNC() gives non-const pointer of a module. NC stands for non-const.</p>
    <pre class="example"><span class="code_comment">// Declaration of a pointer to a module you want to access.</span>
YourModule* ym;

<span class="code_comment">// Get a pointer to the module.</span>
GetANLModuleNC("YourModule", ym);

<span class="code_comment">// Call methods of the module.</span>
ym->setMode(mode);
ym->doSomething();
</pre>
    
    <h3>4.3 Use of Ruby Interface</h3>
    <p>The ANL Next framework provides Ruby binding. This feature makes the framework flexible and powerful.</p>
    <p>To use the extension libarary, it is necessary to "require" ANL libraries.</p>
    <pre class="example">
require 'monaco' # One of Ruby extension libararies.
require 'ANLLib' # Utility library for the ANL-Ruby binding
    </pre>
    <p>At the begenning, we define an analysis chain composed of ANL modules.</p>
    <pre class="example">
anl = ANLApp.new
anl.chain :SaveData
anl.chain :CSHitCollection
anl.chain :ConstructDetector_Sim
anl.chain :SetNoiseLevel
anl.chain :Megalib2G4Geom
anl.chain :AHStdPhysicsList_ANL
anl.chain :PlaneWaveRectanglePrimaryGen
anl.chain :Geant4Body
anl.chain :NextPickUpData
anl.chain :MakeDetectorHit
anl.chain :EventSelection
anl.chain :HitTree_Sim
    </pre>
    <p>Then, we set parameters of the modules. If you do not set parameters here, default values will be assigned.</p>
    <pre class="example">
dbDir = "../database/"
anl.set_parameters :SaveData, {
  'Output file' => "sim_compton_camera.root"
}

anl.set_parameters :ConstructDetector_Sim, {
  'Detector configuration file' => dbDir+'detector_config_sgd.xml',
  'Simulation parameter file' => dbDir+'sdlist_sgd.xml',
}
    </pre>
    <p>If an ANL module has a map parameter, you can insert a new map element in this way:</p>
    <pre class="example">
anl.set_parameters :SetNoiseLevel
anl.insert_map 'Noise level map', 'Si', {
  'Detector type' => 1,
  'Noise parameter 00' => 1.5,
  'Noise parameter 01' => 0.0,
  'Noise parameter 02' => 0.003,
}
anl.insert_map 'Noise level map', 'CdTe', {
  'Detector type' => 1,
  'Noise parameter 00' => 1.6,
  'Noise parameter 01' => 0.0,
  'Noise parameter 02' => 0.01,
}
    </pre>

    <p>After setting the parameter, just run the ANL. The number of the analysis loop can be passed through the first argument. The second argument is optional for setting the display frequency.</p>
    <pre class="example">
anl.run(10000)
    </pre>

    <h2>Class Library Reference</h2>
    
    <div>
      <hr />
      <address>e-mail: odaka(AT)astro.isas.jaxa.jp</address>
    </div>
    
  </body>
</html>
