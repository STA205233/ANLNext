<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  
  <head>
    <meta name="author" content="ODAKA Hirokazu" />
    <meta name="copyright" content="Copyright (c) 2008 Hirokazu Odaka and Compton Team" />
    <link rel="stylesheet" href="design_top.css" type="text/css" />
    <title>ANL Next Framework</title>
  </head>

  <body>
    <!--div><a href="index.html">Home</a></div-->
    
    <h1>ANL Next Framework</h1>
    
    <h2>1. Introduction</h2>
    
    <p>ANL Next is a framework to generate software which performs event-by-event analysis. The event-by-event analysis is defined as data analysis which treats a list of event entries as input and applies some processes to each event entry. Since algorithm for each entry must be identical for all events, the entire program consists of a loop of a procedure that realizes the algorithm for all the entires. We usually need such a data processing for experimental data obtained with radiation detectors including X-ray and gamma-ray telescopes for high-energy astrophysics.</p>

    <p>ANL Next provides us with easy ways to develop and run a software application of event-by-event analysis. In this framework, an analysis loop is treated as an "analysis chain", which is a list of "ANL modules". Each ANL module is responsible for one single task, or relatively simple process. In a single loop, the manager process sequentially calls ANL modules in the analysis chain. In this scheme, Users can concentrate on the simple task applied to one event entry. Once modules are prepared, the users can run applications with various configurations of the analysis chain, without additional development.</p>

    <p>While ANL Next adopts the conventional ANL concept about the event-by-event loop, we have written the code completely from scratch. This framework is written in C++, and provides Ruby binding (extention library) for dynamical and flexible use of analysis applications. To operate an analysis applications, what you need to do is only writing a simple Ruby script, in which you define an analysis chain and set parameters to the ANL modules. The application build by ANL Next are as fast as C++ code, and as flexible as Ruby code.</p>

    <p>This framework is originated from the ANL++ framework (by Shin Watanabe), which is C++ implementation of ANL. ANL is a fundamental framework of event-by-event analysis, which has been used for data processing of X-ray detectors on board ASCA and Suzaku X-ray observatories.</p>
    
    <h3>GitHub</h3>
    <p><a href="https://github.com/odakahirokazu/ANLNext/">https://github.com/odakahirokazu/ANLNext</a></p>

    <h3>Contact</h3>
    <p>Hirokazu Odaka<br />ISAS/JAXA<br />odaka(AT)astro.isas.jaxa.jp</p>

    <h2>2. Installation</h2>
    <p>See <a href="https://github.com/odakahirokazu/ANLNext#readme">README</a> on the github repository.</p>
    
    <h2>3. Getting Started</h2>
    <p>By using this framework, you can easily construct your own applications. If you want a new application containing only existing modules, you can quickly start with writing a Ruby script that defines an "analysis chain" descibing an order of the ANL modules and sets parameters passed to the modules. This enviroment provides you with powerful and flexible scripting framework.</p>

    <h3>3.1 How to write a Ruby script operating an ANL application</h3>
    <p>The ANL Next framework provides Ruby binding. This feature makes the framework flexible and powerful.</p>
    <p>To use the extension libarary, it is necessary to "require" ANL libraries.</p>
    <pre class="example">
require 'ANLLib'      <span class="code_comment"># ANL Next library</span>
require 'comptonSoft' <span class="code_comment"># One of Ruby extension libararies using ANL Next</span>

include ComptonSoft   <span class="code_comment"># need to include the module</span>
    </pre>
    <p>At the begenning, we need to define an analysis chain, which specifies the order of ANL modules.</p>
    <pre class="example">
<span class="code_comment"># create an ANL application.</span>
anl = ANLApp.new

<span class="code_comment"># define an analysis chain.</span>
anl.chain :SaveData
anl.chain :CSHitCollection
anl.chain :ConstructDetector
anl.chain :ConstructChannelTable
anl.chain :ReadDetectorHitTree
anl.chain :AnalyzeHit
anl.chain :EventSelection
anl.chain :HitTree_Sim
    </pre>

    <p>Then, we set parameters of the modules. If you do not set parameters here, default values will be assigned.</p>
    <pre class="example">
anl.set_parameters :SaveData, {
  "Output file" =&gt; "output.root",
}

anl.set_parameters :ConstructDetector, {
  "Detector configuration file" =&gt; "database/detector_configuration_HXI.xml",
}

anl.set_parameters :EventSelection, {
  "Detector group file" =&gt; "database/detector_group_HXI.txt",
  "Remove veto events?" =&gt; true,
  "Range of fluorescence lines" =&gt; 1.0,
}
    </pre>
    <p>If an ANL module has a map parameter, you can insert a new map element in this way:</p>
    <pre class="example">
anl.set_parameters :AnalyzeHit
anl.insert_map "Analysis map", "CdTe", {
  "Detector type" =&gt; 2,
  "Analysis mode" =&gt; 4,
  "Threshold (cathode)" =&gt; 5.0,
  "Threshold (anode)" =&gt; 5.0,
}
anl.insert_map "Analysis map", "Si", {
  "Detector type" =&gt; 2,
  "Analysis mode" =&gt; 4,
  "Threshold (cathode)" =&gt; 3.0,
  "Threshold (anode)" =&gt; 5.0,
}
anl.insert_map "Analysis map", "BGOTop", {
  "Detector type" =&gt; 3,
  "Analysis mode" =&gt; 0,
  "Threshold" =&gt; 100.0,
}
    </pre>
    
    <p>After setting the parameter, just run the ANL. The number of the analysis loop can be passed through the first argument. The second argument is optional for setting the display frequency.</p>
    <pre class="example">
anl.run(100000)
    </pre>
    <p>If you need to set infinite loop, set -1 as the loop number. The second argument is the display frequency (optional).</p>
    <pre class="example">
anl.run(-1, 100000)
    </pre>

    <h3>3.2 ANL model</h3>
    <p>...</p>

    <h2>4. How to Develop Your Applications</h2>
    <p>If you want to develop analysis software which applies your original algorithm, you need to develop a new ANL module. You can find a simple example of your own ANL application in "example" directory.</p>
    
    <h3>4.1 Development of an ANL Module</h3>

    <h4>Structure of ANL module</h4>

    <h4>Methods defined in an ANL module</h4>

    <h4>Registering parameters</h4>

    <h3>4.2 Data Sharing between ANL Modules</h3>
    
    <h4>Event selection flag (EVS)</h4>

    <h4>Accessing information in other modules</h4>
    <p>You can access other modules via GetANLModule() method.</p>
    <pre class="example"><span class="code_comment">// Declaration of a const pointer to a module you want to access.</span>
const YourModule* ym;

<span class="code_comment">// Get a pointer to the module.</span>
GetANLModule("YourModule", ym);

<span class="code_comment">// Get some parameter via a member method of the module.</span>
<span class="code_comment">// The member method must be declared as const.</span>
int yourParam = ym->getYourParam();
</pre>

    <h4>Access to other modules without "const"</h4>
    <p>GetANLModuleNC() gives non-const pointer of a module. NC stands for non-const.</p>
    <pre class="example"><span class="code_comment">// Declaration of a pointer to a module you want to access.</span>
YourModule* ym;

<span class="code_comment">// Get a pointer to the module.</span>
GetANLModuleNC("YourModule", ym);

<span class="code_comment">// Call methods of the module.</span>
ym->setMode(mode);
ym->doSomething();
</pre>
    
    <h3>4.2 Ruby binding</h3>

    <h3>4.3 Build settting</h3>

    <h3>4.4 Run</h3>

    <h2><a href="doxygen/index.html">Class Library Reference</a></h2>
    
    <div>
      <hr />
      <address>e-mail: odaka(AT)astro.isas.jaxa.jp</address>
    </div>
    
  </body>
</html>
